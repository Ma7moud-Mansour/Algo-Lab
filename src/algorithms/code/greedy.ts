import { AlgorithmCode } from '@/types/algorithm';

export const fractionalKnapsackCode: Record<string, AlgorithmCode> = {
  javascript: {
    language: 'javascript',
    lines: [
      'function fractionalKnapsack(items, capacity) {',
      '  // Calculate value-to-weight ratio for each item',
      '  const itemsWithRatio = items.map((item, i) => ({',
      '    ...item,',
      '    index: i,',
      '    ratio: item.value / item.weight',
      '  }));',
      '',
      '  // Sort by ratio in descending order',
      '  itemsWithRatio.sort((a, b) => b.ratio - a.ratio);',
      '',
      '  let totalValue = 0;',
      '  let remainingCapacity = capacity;',
      '  const result = [];',
      '',
      '  for (const item of itemsWithRatio) {',
      '    if (remainingCapacity === 0) break;',
      '',
      '    if (item.weight <= remainingCapacity) {',
      '      // Take the whole item',
      '      result.push({ ...item, fraction: 1 });',
      '      totalValue += item.value;',
      '      remainingCapacity -= item.weight;',
      '    } else {',
      '      // Take a fraction of the item',
      '      const fraction = remainingCapacity / item.weight;',
      '      result.push({ ...item, fraction });',
      '      totalValue += item.value * fraction;',
      '      remainingCapacity = 0;',
      '    }',
      '  }',
      '',
      '  return { result, totalValue };',
      '}',
    ],
  },
  python: {
    language: 'python',
    lines: [
      'def fractional_knapsack(items, capacity):',
      '    # Calculate value-to-weight ratio for each item',
      '    items_with_ratio = [',
      '        {**item, "index": i, "ratio": item["value"] / item["weight"]}',
      '        for i, item in enumerate(items)',
      '    ]',
      '',
      '    # Sort by ratio in descending order',
      '    items_with_ratio.sort(key=lambda x: x["ratio"], reverse=True)',
      '',
      '    total_value = 0',
      '    remaining_capacity = capacity',
      '    result = []',
      '',
      '    for item in items_with_ratio:',
      '        if remaining_capacity == 0:',
      '            break',
      '',
      '        if item["weight"] <= remaining_capacity:',
      '            # Take the whole item',
      '            result.append({**item, "fraction": 1})',
      '            total_value += item["value"]',
      '            remaining_capacity -= item["weight"]',
      '        else:',
      '            # Take a fraction of the item',
      '            fraction = remaining_capacity / item["weight"]',
      '            result.append({**item, "fraction": fraction})',
      '            total_value += item["value"] * fraction',
      '            remaining_capacity = 0',
      '',
      '    return result, total_value',
    ],
  },
  pseudocode: {
    language: 'pseudocode',
    lines: [
      'FRACTIONAL-KNAPSACK(items, capacity):',
      '  // Calculate ratio for each item',
      '  for each item in items:',
      '    item.ratio = item.value / item.weight',
      '',
      '  // Sort items by ratio descending',
      '  SORT items by ratio (descending)',
      '',
      '  totalValue = 0',
      '  remainingCapacity = capacity',
      '  result = []',
      '',
      '  for each item in sorted items:',
      '    if remainingCapacity = 0:',
      '      break',
      '',
      '    if item.weight ≤ remainingCapacity:',
      '      // Take whole item',
      '      ADD item to result with fraction = 1',
      '      totalValue += item.value',
      '      remainingCapacity -= item.weight',
      '    else:',
      '      // Take fraction of item',
      '      fraction = remainingCapacity / item.weight',
      '      ADD item to result with fraction',
      '      totalValue += item.value × fraction',
      '      remainingCapacity = 0',
      '',
      '  return result, totalValue',
    ],
  },
};

export const optimalMergeCode: Record<string, AlgorithmCode> = {
  javascript: {
    language: 'javascript',
    lines: [
      'function optimalMergePattern(fileSizes) {',
      '  if (fileSizes.length <= 1) return 0;',
      '',
      '  // Create a min-heap (priority queue)',
      '  const heap = [...fileSizes].sort((a, b) => a - b);',
      '  let totalCost = 0;',
      '',
      '  while (heap.length > 1) {',
      '    // Extract two smallest files',
      '    const first = heap.shift();',
      '    const second = heap.shift();',
      '',
      '    // Merge cost is sum of both files',
      '    const mergeCost = first + second;',
      '    totalCost += mergeCost;',
      '',
      '    // Insert merged file back into heap',
      '    // Find correct position to maintain sorted order',
      '    let insertIndex = 0;',
      '    while (insertIndex < heap.length && ',
      '           heap[insertIndex] < mergeCost) {',
      '      insertIndex++;',
      '    }',
      '    heap.splice(insertIndex, 0, mergeCost);',
      '  }',
      '',
      '  return totalCost;',
      '}',
    ],
  },
  python: {
    language: 'python',
    lines: [
      'import heapq',
      '',
      'def optimal_merge_pattern(file_sizes):',
      '    if len(file_sizes) <= 1:',
      '        return 0',
      '',
      '    # Create a min-heap',
      '    heap = file_sizes.copy()',
      '    heapq.heapify(heap)',
      '    total_cost = 0',
      '',
      '    while len(heap) > 1:',
      '        # Extract two smallest files',
      '        first = heapq.heappop(heap)',
      '        second = heapq.heappop(heap)',
      '',
      '        # Merge cost is sum of both files',
      '        merge_cost = first + second',
      '        total_cost += merge_cost',
      '',
      '        # Insert merged file back into heap',
      '        heapq.heappush(heap, merge_cost)',
      '',
      '    return total_cost',
    ],
  },
  pseudocode: {
    language: 'pseudocode',
    lines: [
      'OPTIMAL-MERGE-PATTERN(fileSizes):',
      '  if length(fileSizes) ≤ 1:',
      '    return 0',
      '',
      '  // Create min-heap from file sizes',
      '  heap = MIN-HEAP(fileSizes)',
      '  totalCost = 0',
      '',
      '  while heap.size > 1:',
      '    // Extract two smallest files',
      '    first = EXTRACT-MIN(heap)',
      '    second = EXTRACT-MIN(heap)',
      '',
      '    // Calculate merge cost',
      '    mergeCost = first + second',
      '    totalCost += mergeCost',
      '',
      '    // Insert merged file back',
      '    INSERT(heap, mergeCost)',
      '',
      '  return totalCost',
    ],
  },
};

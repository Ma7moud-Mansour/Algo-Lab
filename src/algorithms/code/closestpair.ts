import { AlgorithmCode } from '@/types/algorithm';

export const closestPairCode: Record<string, AlgorithmCode> = {
  javascript: {
    language: 'javascript',
    lines: [
      'function closestPair(points) {',
      '  let minDist = Infinity;',
      '  let closestPair = null;',
      '  ',
      '  // Compare every pair of points',
      '  for (let i = 0; i < points.length; i++) {',
      '    for (let j = i + 1; j < points.length; j++) {',
      '      // Calculate Euclidean distance',
      '      const dist = distance(points[i], points[j]);',
      '      ',
      '      // Update if this pair is closer',
      '      if (dist < minDist) {',
      '        minDist = dist;',
      '        closestPair = [points[i], points[j]];',
      '      }',
      '    }',
      '  }',
      '  ',
      '  return { pair: closestPair, distance: minDist };',
      '}',
      '',
      'function distance(p1, p2) {',
      '  const dx = p2.x - p1.x;',
      '  const dy = p2.y - p1.y;',
      '  return Math.sqrt(dx * dx + dy * dy);',
      '}',
    ],
  },
  python: {
    language: 'python',
    lines: [
      'def closest_pair(points):',
      '    min_dist = float("inf")',
      '    closest = None',
      '    ',
      '    # Compare every pair of points',
      '    for i in range(len(points)):',
      '        for j in range(i + 1, len(points)):',
      '            # Calculate Euclidean distance',
      '            dist = distance(points[i], points[j])',
      '            ',
      '            # Update if this pair is closer',
      '            if dist < min_dist:',
      '                min_dist = dist',
      '                closest = (points[i], points[j])',
      '    ',
      '    return closest, min_dist',
      '',
      'def distance(p1, p2):',
      '    dx = p2[0] - p1[0]',
      '    dy = p2[1] - p1[1]',
      '    return (dx**2 + dy**2) ** 0.5',
    ],
  },
  pseudocode: {
    language: 'pseudocode',
    lines: [
      'CLOSEST_PAIR(points):',
      '    minDist ← INFINITY',
      '    closestPair ← NULL',
      '    ',
      '    // Compare every pair of points (brute force)',
      '    FOR i ← 0 TO length(points) - 1:',
      '        FOR j ← i + 1 TO length(points) - 1:',
      '            ',
      '            // Calculate Euclidean distance',
      '            dist ← DISTANCE(points[i], points[j])',
      '            ',
      '            // Update if this pair is closer',
      '            IF dist < minDist THEN',
      '                minDist ← dist',
      '                closestPair ← (points[i], points[j])',
      '    ',
      '    RETURN closestPair, minDist',
      '',
      'DISTANCE(p1, p2):',
      '    dx ← p2.x - p1.x',
      '    dy ← p2.y - p1.y',
      '    RETURN sqrt(dx² + dy²)',
    ],
  },
};
